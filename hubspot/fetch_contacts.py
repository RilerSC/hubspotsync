#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
================================================================================
                            HUBSPOT CONTACTS - EXTRACTOR DE CONTACTOS
================================================================================

Archivo:            hubspot/fetch_contacts.py
Descripci√≥n:        M√≥dulo especializado para la extracci√≥n y procesamiento de
                   contactos desde la API de HubSpot. Incluye an√°lisis din√°mico
                   de propiedades, extracci√≥n por lotes optimizada y manejo
                   robusto de grandes vol√∫menes de datos de contactos.

Dependencias:
    - HubSpot API v3
    - Variables de entorno: HUBSPOT_TOKEN
    - Librer√≠as: requests, dotenv, os, pathlib

Autor:              Ing. Jose R√≠ler Sol√≥rzano Campos
Fecha de Creaci√≥n:  11 de julio de 2025
Derechos de Autor:  ¬© 2025 Jose R√≠ler Sol√≥rzano Campos. Todos los derechos reservados.
Licencia:           Uso exclusivo del autor. Prohibida la distribuci√≥n sin autorizaci√≥n.

================================================================================
"""

import os
import requests
import pandas as pd
from dotenv import load_dotenv
from pathlib import Path
from tabulate import tabulate
import time

# Cargar variables de entorno
env_path = Path(__file__).resolve().parent.parent / ".env"
load_dotenv(dotenv_path=env_path)

# Lista que se llenar√° din√°micamente solo con propiedades que tienen datos
CONTACT_PROPERTIES = []

def get_all_contact_properties():
    """
    Obtiene todas las propiedades disponibles para contacts
    """
    url = "https://api.hubapi.com/crm/v3/properties/contacts"
    headers = {
        "Authorization": f"Bearer {os.getenv('HUBSPOT_TOKEN')}",
        "Content-Type": "application/json"
    }

    print("üîç Obteniendo lista de propiedades de contactos...")
    try:
        response = requests.get(url, headers=headers)
        if response.status_code != 200:
            print(f"‚ùå Error obteniendo propiedades: {response.status_code}")
            return []

        data = response.json()
        properties = [prop.get("name") for prop in data.get("results", []) if prop.get("name")]
        print(f"‚úÖ Propiedades de contactos disponibles: {len(properties)}")
        return properties

    except Exception as e:
        print(f"‚ùå Error: {str(e)}")
        return []

def analyze_all_contact_properties_in_chunks():
    """
    Analiza TODAS las propiedades de contactos en lotes para encontrar cu√°les tienen datos
    """
    all_properties = get_all_contact_properties()
    
    if not all_properties:
        print("‚ùå No se pudieron obtener las propiedades")
        return []

    print(f"üéØ Analizando TODAS las {len(all_properties)} propiedades de contactos en lotes...")
    
    # Dividir en chunks de 80 propiedades
    chunk_size = 80
    properties_with_data = []
    
    for i in range(0, len(all_properties), chunk_size):
        chunk = all_properties[i:i+chunk_size]
        print(f"üì¶ Analizando lote {i//chunk_size + 1}/{(len(all_properties)-1)//chunk_size + 1}: {len(chunk)} propiedades")
        
        chunk_results = analyze_contact_chunk_with_post(chunk, chunk_number=i//chunk_size + 1)
        if chunk_results:
            properties_with_data.extend(chunk_results)
        
        # Peque√±a pausa para no sobrecargar la API
        time.sleep(0.5)
    
    # Remover duplicados y ordenar
    properties_with_data = list(set(properties_with_data))
    print(f"üéâ TOTAL de propiedades de contactos con datos: {len(properties_with_data)}")
    
    return properties_with_data

def analyze_contact_chunk_with_post(properties_chunk, chunk_number=1):
    """
    Analiza un lote de propiedades de contactos usando POST
    """
    url = "https://api.hubapi.com/crm/v3/objects/contacts/search"
    headers = {
        "Authorization": f"Bearer {os.getenv('HUBSPOT_TOKEN')}",
        "Content-Type": "application/json"
    }

    # Payload para POST
    payload = {
        "limit": 100,  # M√°s contactos para an√°lisis m√°s preciso
        "properties": properties_chunk,
        "filterGroups": [
            {
                "filters": [
                    {
                        "propertyName": "hs_object_id",
                        "operator": "HAS_PROPERTY"
                    }
                ]
            }
        ]
    }

    try:
        response = requests.post(url, headers=headers, json=payload)
        if response.status_code != 200:
            print(f"‚ùå Error en lote {chunk_number}: {response.status_code}")
            return []

        data = response.json()
        sample_contacts = data.get("results", [])
        
        if not sample_contacts:
            print(f"‚ö†Ô∏è Lote {chunk_number}: Sin contactos obtenidos")
            return []

        # Analizar qu√© propiedades de este chunk tienen datos
        chunk_properties_with_data = analyze_contact_properties_in_chunk(sample_contacts, properties_chunk)
        
        print(f"‚úÖ Lote {chunk_number}: {len(chunk_properties_with_data)}/{len(properties_chunk)} propiedades con datos")
        
        return chunk_properties_with_data

    except Exception as e:
        print(f"‚ùå Error en lote {chunk_number}: {str(e)}")
        return []

def analyze_contact_properties_in_chunk(sample_contacts, properties_chunk):
    """
    Analiza un lote espec√≠fico de contactos para ver qu√© propiedades tienen datos
    """
    if not sample_contacts:
        return []

    # Contar propiedades que tienen valores no vac√≠os
    property_stats = {}
    
    for contact in sample_contacts:
        props = contact.get("properties", {})
        for prop_name in properties_chunk:
            prop_value = props.get(prop_name)
            
            if prop_name not in property_stats:
                property_stats[prop_name] = {"total": 0, "with_data": 0}
            
            property_stats[prop_name]["total"] += 1
            
            # Verificar si tiene datos reales
            if prop_value and str(prop_value).strip() and str(prop_value) not in ["None", "null", ""]:
                property_stats[prop_name]["with_data"] += 1

    # Filtrar propiedades que tienen datos en al menos el 1% de los registros
    properties_with_data = []
    for prop_name, stats in property_stats.items():
        if stats["with_data"] > 0:  # Al menos 1 registro con datos
            percentage = (stats["with_data"] / stats["total"]) * 100
            if percentage >= 1.0:  # Al menos 1% de los contactos tienen esta propiedad
                properties_with_data.append(prop_name)

    return properties_with_data

def fetch_contacts_from_hubspot():
    """
    Funci√≥n principal para extracci√≥n completa de contactos desde HubSpot API.
    
    Descripci√≥n:
        Coordina el proceso completo de extracci√≥n de contactos, desde el an√°lisis
        din√°mico de propiedades hasta la obtenci√≥n de datos completos. Esta funci√≥n
        maneja grandes vol√∫menes de contactos (t√≠picamente 5000+) de manera optimizada.
        
    Flujo de Procesamiento:
        1. Ejecuta an√°lisis completo de propiedades con analyze_all_contact_properties_in_chunks()
        2. Identifica ~260 propiedades √∫tiles de ~568 disponibles (46% optimizaci√≥n)
        3. Actualiza variable global CONTACT_PROPERTIES con propiedades filtradas
        4. Ejecuta extracci√≥n masiva usando fetch_all_contacts_with_post()
        5. Retorna lista completa de contactos con propiedades optimizadas
        
    Estrategia de Optimizaci√≥n:
        - An√°lisis din√°mico: Solo extrae propiedades que contienen datos reales
        - Fallback robusto: Usa propiedades b√°sicas si falla el an√°lisis
        - Procesamiento por lotes: Maneja eficientemente grandes vol√∫menes
        
    Dependencias:
        - analyze_all_contact_properties_in_chunks(): Para an√°lisis de propiedades
        - fetch_all_contacts_with_post(): Para extracci√≥n masiva optimizada
        - Variable global CONTACT_PROPERTIES: Para almacenar propiedades √∫tiles
        
    Retorna:
        list: Lista de diccionarios con contactos y sus propiedades
        list vac√≠a: En caso de error o no encontrar datos
        
    Efectos Secundarios:
        - Actualiza CONTACT_PROPERTIES global
        - Imprime estad√≠sticas de progreso en consola
        
    Uso desde main.py:
        contacts = fetch_contacts_from_hubspot()
        
    Performance:
        Tiempo estimado: 3-4 minutos para ~5000 contactos con ~260 propiedades
        
    Volumen T√≠pico:
        - Contactos: ~5000 registros
        - Propiedades analizadas: ~260 de 568 disponibles
        - Eficiencia: ~54% de optimizaci√≥n en propiedades
    """
    # ==================== FASE 1: AN√ÅLISIS DE PROPIEDADES ====================
    # Analizar TODAS las propiedades disponibles para encontrar las √∫tiles
    print("üöÄ Iniciando an√°lisis COMPLETO de propiedades de CONTACTOS...")
    properties_with_data = analyze_all_contact_properties_in_chunks()
    
    # ==================== FALLBACK: PROPIEDADES B√ÅSICAS ====================
    # Si falla el an√°lisis, usar conjunto m√≠nimo de propiedades esenciales para contactos
    if not properties_with_data:
        print("‚ö†Ô∏è No se pudo analizar propiedades. Usando b√°sicas...")
        properties_with_data = [
            "hs_object_id", "email", "firstname", "lastname", "phone", 
            "company", "createdate", "lastmodifieddate", "hubspot_owner_id"
        ]
    
    # ==================== ACTUALIZACI√ìN DE VARIABLE GLOBAL ====================
    # Actualizar la lista global para uso en otras funciones del m√≥dulo
    global CONTACT_PROPERTIES
    CONTACT_PROPERTIES = properties_with_data
    
    print(f"\nüéØ Obteniendo TODOS los contactos con {len(properties_with_data)} propiedades √∫tiles...")
    
    # Usar POST para obtener todos los contactos
    return fetch_all_contacts_with_post(properties_with_data)

def fetch_all_contacts_with_post(properties_list):
    """
    Obtiene todos los contactos usando POST dividiendo las propiedades si es necesario
    """
    # Si hay demasiadas propiedades, hacer m√∫ltiples calls
    if len(properties_list) > 100:
        print(f"‚ö†Ô∏è Demasiadas propiedades ({len(properties_list)}), dividiendo en lotes...")
        return fetch_contacts_in_property_batches(properties_list)
    
    url = "https://api.hubapi.com/crm/v3/objects/contacts/search"
    headers = {
        "Authorization": f"Bearer {os.getenv('HUBSPOT_TOKEN')}",
        "Content-Type": "application/json"
    }

    all_contacts = []
    after = None
    page_count = 0

    while True:
        # Payload para POST
        payload = {
            "limit": 100,
            "properties": properties_list,
            "filterGroups": [
                {
                    "filters": [
                        {
                            "propertyName": "hs_object_id",
                            "operator": "HAS_PROPERTY"
                        }
                    ]
                }
            ]
        }
        
        # Agregar paginaci√≥n si existe
        if after:
            payload["after"] = after

        try:
            response = requests.post(url, headers=headers, json=payload)
            if response.status_code != 200:
                print(f"‚ùå Error HTTP {response.status_code}")
                print(f"‚ùå Respuesta: {response.text}")
                break

            data = response.json()
            contacts = data.get("results", [])
            all_contacts.extend(contacts)
            page_count += 1
            
            print(f"üìÑ P√°gina {page_count}: {len(contacts)} contactos obtenidos (Total: {len(all_contacts)})")

            # Verificar si hay m√°s p√°ginas
            paging = data.get("paging")
            if paging and paging.get("next") and paging["next"].get("after"):
                after = paging["next"]["after"]
            else:
                break

        except requests.exceptions.RequestException as e:
            print(f"‚ùå Error en la petici√≥n: {str(e)}")
            break
        except Exception as e:
            print(f"‚ùå Error inesperado: {str(e)}")
            break

    print(f"‚úÖ Total de contactos obtenidos: {len(all_contacts)}")
    return all_contacts

def fetch_contacts_in_property_batches(properties_list):
    """
    Obtiene contactos en lotes de propiedades y luego los combina
    """
    print(f"üì¶ Dividiendo {len(properties_list)} propiedades en lotes de 80...")
    
    # Propiedades esenciales que deben estar en todos los lotes
    essential_props = ["hs_object_id"]
    
    # Dividir propiedades no esenciales en lotes
    non_essential = [p for p in properties_list if p not in essential_props]
    batch_size = 80
    
    all_contacts_data = {}  # Diccionario para combinar datos por ID
    
    for i in range(0, len(non_essential), batch_size):
        batch_props = essential_props + non_essential[i:i+batch_size]
        batch_num = i//batch_size + 1
        total_batches = (len(non_essential)-1)//batch_size + 1
        
        print(f"üì¶ Procesando lote {batch_num}/{total_batches} con {len(batch_props)} propiedades...")
        
        batch_contacts = fetch_all_contacts_with_post(batch_props)
        
        # Combinar datos por ID
        for contact in batch_contacts:
            contact_id = contact.get("properties", {}).get("hs_object_id")
            if contact_id:
                if contact_id not in all_contacts_data:
                    all_contacts_data[contact_id] = {"properties": {}}
                
                # Combinar propiedades
                all_contacts_data[contact_id]["properties"].update(contact.get("properties", {}))
        
        print(f"‚úÖ Lote {batch_num} procesado. Contactos √∫nicos acumulados: {len(all_contacts_data)}")
    
    # Convertir diccionario de vuelta a lista
    combined_contacts = list(all_contacts_data.values())
    print(f"üéØ Combinaci√≥n completa: {len(combined_contacts)} contactos con datos completos")
    
    return combined_contacts

def get_all_contact_properties_list():
    """
    Funci√≥n para obtener la lista de propiedades que tienen datos
    """
    return CONTACT_PROPERTIES

def display_contacts_summary(contacts):
    """
    Muestra un resumen extendido de contactos
    """
    if not contacts:
        print("‚ö†Ô∏è No hay contactos para mostrar")
        return

    print(f"\nüìä RESUMEN EXTENDIDO DE CONTACTOS ({len(contacts)} total)")
    print("=" * 60)
    
    # Crear DataFrame para an√°lisis
    all_props_data = []
    for contact in contacts:
        all_props_data.append(contact.get("properties", {}))
    
    df = pd.DataFrame(all_props_data)
    
    # Mostrar estad√≠sticas de completitud de datos
    print("\nüìà ESTAD√çSTICAS DE COMPLETITUD DE DATOS:")
    prop_stats = []
    for col in df.columns:
        actual_data_count = ((df[col].notna()) & (df[col] != "") & (df[col] != "None")).sum()
        
        if actual_data_count > 0:
            prop_stats.append({
                "propiedad": col,
                "con_datos": actual_data_count,
                "porcentaje": (actual_data_count / len(df)) * 100
            })
    
    # Ordenar por porcentaje
    prop_stats.sort(key=lambda x: x["porcentaje"], reverse=True)
    
    # Mostrar top 15
    print("\nüîù TOP 15 PROPIEDADES DE CONTACTOS CON M√ÅS DATOS:")
    for i, stat in enumerate(prop_stats[:15], 1):
        print(f"   {i:2d}. {stat['propiedad']:<30} {stat['porcentaje']:5.1f}% ({stat['con_datos']}/{len(df)})")
    
    # Estad√≠sticas generales
    total_props = len(CONTACT_PROPERTIES)
    props_with_50_percent = len([p for p in prop_stats if p["porcentaje"] >= 50])
    props_with_10_percent = len([p for p in prop_stats if p["porcentaje"] >= 10])
    
    print(f"\nüìä RESUMEN DE PROPIEDADES:")
    print(f"   üéØ Total de propiedades √∫tiles: {total_props}")
    print(f"   üí™ Con datos en >50% de contactos: {props_with_50_percent}")
    print(f"   üìà Con datos en >10% de contactos: {props_with_10_percent}")
    print(f"   üìâ Con datos en <10% de contactos: {total_props - props_with_10_percent}")

def main():
    """
    Funci√≥n principal para ejecutar el script directamente
    """
    print("üöÄ HUBSPOT CONTACTS FETCHER - AN√ÅLISIS COMPLETO DE TODAS LAS PROPIEDADES")
    print("=" * 80)
    
    # Verificar token
    token = os.getenv('HUBSPOT_TOKEN')
    if not token:
        print("‚ùå Error: No se encontr√≥ HUBSPOT_TOKEN en las variables de entorno")
        return

    # Obtener contactos con an√°lisis completo
    contacts = fetch_contacts_from_hubspot()
    
    if not contacts:
        print("‚ö†Ô∏è No se obtuvieron contactos")
        return

    # Mostrar resumen extendido
    display_contacts_summary(contacts)

if __name__ == "__main__":
    main()